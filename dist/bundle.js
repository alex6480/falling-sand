/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Dust.ts":
/*!*********************!*\
  !*** ./src/Dust.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DustBase\": () => (/* binding */ DustBase)\n/* harmony export */ });\nvar DustBase = /** @class */ (function () {\r\n    function DustBase(color) {\r\n        this.rendered = false;\r\n        this.active = true;\r\n        this.noise = Math.random();\r\n        this.color = color;\r\n    }\r\n    DustBase.prototype.step = function (world, x, y) {\r\n    };\r\n    DustBase.prototype.render = function (setColor) {\r\n        var brightness = 1 - this.noise * 0.2;\r\n        setColor(this.color.red * brightness, this.color.green * brightness, this.color.blue * brightness);\r\n    };\r\n    DustBase.prototype.activate = function () {\r\n        this.active = true;\r\n    };\r\n    return DustBase;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/Dust.ts?");

/***/ }),

/***/ "./src/DustType/Gas.ts":
/*!*****************************!*\
  !*** ./src/DustType/Gas.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gas\": () => (/* binding */ Gas)\n/* harmony export */ });\n/* harmony import */ var _Liquid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Liquid */ \"./src/DustType/Liquid.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar Gas = /** @class */ (function (_super) {\r\n    __extends(Gas, _super);\r\n    function Gas() {\r\n        var _this = _super.call(this) || this;\r\n        _this.velocity = 0;\r\n        _this.gravityFactor = 0.5;\r\n        _this.maxSpeed = 1;\r\n        _this.lastFrame = 0;\r\n        _this.color = {\r\n            red: 180,\r\n            blue: 170,\r\n            green: 30\r\n        };\r\n        _this.dispersionAmount = 1;\r\n        return _this;\r\n    }\r\n    Gas.prototype.step = function (world, x, y) {\r\n        if (world.frame <= this.lastFrame) {\r\n            return;\r\n        }\r\n        this.lastFrame = world.frame;\r\n        var dustAbove = world.dust.get(x, y - 1);\r\n        var newX = x;\r\n        var newY = y;\r\n        var shouldInactivate = this.framesSinceLastActivity > 10;\r\n        if (dustAbove === null || (dustAbove.physicsType == \"liquid\" && this.velocity >= dustAbove.velocity)) {\r\n            // If there is space below the current spec of dust, it should fall\r\n            this.dispersionAmount = Math.max(this.dispersionAmount, -this.velocity * this.dispersionFactor);\r\n            this.framesSinceLastActivity = 0;\r\n            this.velocity -= world.gravity * this.gravityFactor;\r\n            shouldInactivate = false;\r\n        }\r\n        else {\r\n            // Try to disperse the liquid sideways\r\n            var dispersionResult = this.tryDisperse(world, newX, newY, -1);\r\n            shouldInactivate = shouldInactivate && this.framesSinceLastActivity > 50;\r\n            newX = dispersionResult.x;\r\n            newY = dispersionResult.y;\r\n            if (dispersionResult.x == x) {\r\n                this.velocity = 0;\r\n            }\r\n            this.dispersionAmount = Math.max(20, Math.floor(this.dispersionAmount * 0.9) - 0.5);\r\n        }\r\n        if (-this.velocity > this.maxSpeed) {\r\n            this.velocity = -this.maxSpeed;\r\n        }\r\n        // Try to move\r\n        var targetY = Math.ceil(newY + this.velocity - this.ySubPixel);\r\n        this.ySubPixel = targetY - (newY + this.velocity - this.ySubPixel);\r\n        for (var stepY = newY - 1; stepY >= targetY; stepY--) {\r\n            var dustAtPosition = world.dust.get(newX, stepY);\r\n            if (this.canMoveInto(dustAtPosition)) {\r\n                newY = stepY;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        this.framesSinceLastActivity++;\r\n        if (newY != y) {\r\n            this.framesSinceLastActivity = 0;\r\n            world.dust.getNeighbors(x, y, 2).forEach(function (dust) { return dust[0].activate(); });\r\n        }\r\n        if (shouldInactivate) {\r\n            // Inactivate the dust spec as no further movement will occur\r\n            this.active = false;\r\n        }\r\n        else {\r\n            // Update the position\r\n            var dustAtTarget = world.dust.get(newX, newY);\r\n            world.dust.set(x, y, dustAtTarget);\r\n            world.dust.set(newX, newY, this);\r\n        }\r\n    };\r\n    return Gas;\r\n}(_Liquid__WEBPACK_IMPORTED_MODULE_0__.Liquid));\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/DustType/Gas.ts?");

/***/ }),

/***/ "./src/DustType/Gravel.ts":
/*!********************************!*\
  !*** ./src/DustType/Gravel.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gravel\": () => (/* binding */ Gravel)\n/* harmony export */ });\n/* harmony import */ var _Sand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sand */ \"./src/DustType/Sand.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar Gravel = /** @class */ (function (_super) {\r\n    __extends(Gravel, _super);\r\n    function Gravel() {\r\n        var _this = _super.call(this) || this;\r\n        _this.dispersionFactor = 0.5;\r\n        _this.dispersionAmount = 0;\r\n        _this.color = {\r\n            red: 180,\r\n            blue: 120,\r\n            green: 180\r\n        };\r\n        _this.dispersionAmount = 1;\r\n        return _this;\r\n    }\r\n    return Gravel;\r\n}(_Sand__WEBPACK_IMPORTED_MODULE_0__.Sand));\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/DustType/Gravel.ts?");

/***/ }),

/***/ "./src/DustType/Liquid.ts":
/*!********************************!*\
  !*** ./src/DustType/Liquid.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Liquid\": () => (/* binding */ Liquid)\n/* harmony export */ });\n/* harmony import */ var _Dust__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Dust */ \"./src/Dust.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar Liquid = /** @class */ (function (_super) {\r\n    __extends(Liquid, _super);\r\n    function Liquid() {\r\n        var _this = _super.call(this, {\r\n            red: 40,\r\n            blue: 250,\r\n            green: 67\r\n        }) || this;\r\n        _this.velocity = 0;\r\n        _this.dispersionFactor = 5;\r\n        _this.dispersionAmount = 0;\r\n        _this.physicsType = \"liquid\";\r\n        _this.framesSinceLastActivity = 0;\r\n        _this.ySubPixel = 0;\r\n        return _this;\r\n    }\r\n    Liquid.prototype.step = function (world, x, y) {\r\n        var dustBelow = world.dust.get(x, y + 1);\r\n        var newX = x;\r\n        var newY = y;\r\n        var shouldInactivate = this.framesSinceLastActivity > 10;\r\n        if (dustBelow === null || (dustBelow.physicsType == \"liquid\" && this.velocity < dustBelow.velocity)) {\r\n            // If there is space below the current spec of dust, it should fall\r\n            this.dispersionAmount = Math.max(this.dispersionAmount, this.velocity * this.dispersionFactor);\r\n            this.framesSinceLastActivity = 0;\r\n            this.velocity += world.gravity;\r\n            shouldInactivate = false;\r\n        }\r\n        else {\r\n            // Try to disperse the liquid sideways\r\n            var dispersionResult = this.tryDisperse(world, newX, newY);\r\n            shouldInactivate = shouldInactivate && this.framesSinceLastActivity > 50;\r\n            newX = dispersionResult.x;\r\n            newY = dispersionResult.y;\r\n            if (dispersionResult.x == x) {\r\n                this.velocity = 0;\r\n                this.ySubPixel = 0;\r\n            }\r\n            this.dispersionAmount = Math.max(20, Math.floor(this.dispersionAmount * 0.9) - 0.5);\r\n        }\r\n        // Try to move\r\n        var targetY = Math.ceil(newY + this.velocity + this.ySubPixel);\r\n        this.ySubPixel = newY + this.velocity + this.ySubPixel - targetY;\r\n        for (var stepY = newY + 1; stepY <= targetY; stepY++) {\r\n            var dustAtPosition = world.dust.get(newX, stepY);\r\n            if (this.canMoveInto(dustAtPosition)) {\r\n                newY = stepY;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        this.framesSinceLastActivity++;\r\n        if (newY != y) {\r\n            this.framesSinceLastActivity = 0;\r\n            world.dust.getNeighbors(x, y, 2).forEach(function (dust) { return dust[0].activate(); });\r\n        }\r\n        if (shouldInactivate) {\r\n            // Inactivate the dust spec as no further movement will occur\r\n            this.active = false;\r\n        }\r\n        else {\r\n            // Update the position\r\n            var dustAtTarget = world.dust.get(newX, newY);\r\n            world.dust.set(x, y, dustAtTarget);\r\n            world.dust.set(newX, newY, this);\r\n        }\r\n    };\r\n    Liquid.prototype.activate = function () {\r\n        _super.prototype.activate.call(this);\r\n        this.framesSinceLastActivity = 0;\r\n    };\r\n    Liquid.prototype.tryDisperse = function (world, x, y, yDirection) {\r\n        if (yDirection === void 0) { yDirection = 1; }\r\n        var directions = Math.random() < 0.5 ? [-1, 1] : [1, -1];\r\n        var distance = 1;\r\n        if (this.dispersionAmount == 0) {\r\n            return { x: x, y: y, dispersion: 0 };\r\n        }\r\n        while (true) {\r\n            var possibleDirections = directions;\r\n            for (var i = 0; i < directions.length; i++) {\r\n                var dir = directions[i];\r\n                var dustAtPosition = world.dust.get(x + dir * distance, y);\r\n                var dustBelow = world.dust.get(x + dir * distance, y + yDirection);\r\n                if (this.canMoveInto(dustAtPosition) || dustAtPosition.physicsType === \"liquid\") {\r\n                    // We can move into this space\r\n                    // There is a random chance that we don't move any further\r\n                    var random = Math.random();\r\n                    if (this.canMoveInto(dustBelow) && random < 0.5 || random < 1 / this.dispersionAmount) {\r\n                        if (dustAtPosition !== null && dustAtPosition.physicsType === \"liquid\") {\r\n                            // We dispersed into another water element, so just stop dispersing\r\n                            return { x: x, y: y, dispersion: 0 };\r\n                        }\r\n                        if (this.canMoveInto(dustBelow)) {\r\n                            return { x: x + distance * dir, y: y + yDirection, dispersion: distance };\r\n                        }\r\n                        else {\r\n                            return { x: x + distance * dir, y: y, dispersion: distance };\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // It is not possible to advance in this direction\r\n                    if (possibleDirections.length === 2) {\r\n                        // Keep on searching in the other direction\r\n                        possibleDirections = [-dir];\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        // We cannot move any further in any direction\r\n                        return { x: x + (distance - 1) * dir, y: y, dispersion: (distance - 1) };\r\n                    }\r\n                }\r\n            }\r\n            directions = possibleDirections;\r\n            distance = distance + 1;\r\n        }\r\n    };\r\n    Liquid.prototype.canMoveInto = function (space) {\r\n        return space === null;\r\n    };\r\n    return Liquid;\r\n}(_Dust__WEBPACK_IMPORTED_MODULE_0__.DustBase));\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/DustType/Liquid.ts?");

/***/ }),

/***/ "./src/DustType/Sand.ts":
/*!******************************!*\
  !*** ./src/DustType/Sand.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Sand\": () => (/* binding */ Sand)\n/* harmony export */ });\n/* harmony import */ var _Dust__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Dust */ \"./src/Dust.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar Sand = /** @class */ (function (_super) {\r\n    __extends(Sand, _super);\r\n    function Sand() {\r\n        var _this = _super.call(this, {\r\n            red: 230,\r\n            blue: 10,\r\n            green: 220\r\n        }) || this;\r\n        _this.velocity = 0;\r\n        _this.dispersionFactor = 2;\r\n        _this.dispersionAmount = 0;\r\n        _this.dispersionDistance = 1;\r\n        _this.physicsType = \"sand\";\r\n        _this.ySubPixel = 0;\r\n        return _this;\r\n    }\r\n    Sand.prototype.step = function (world, x, y) {\r\n        var _this = this;\r\n        var dustBelow = world.dust.get(x, y + 1);\r\n        var newX = x;\r\n        var newY = y;\r\n        if (dustBelow === null || (dustBelow.physicsType == \"sand\" && this.velocity < dustBelow.velocity)) {\r\n            // If there is space below the current spec of dust, it should fall\r\n            //this.velocity.y = Math.max(this.velocity.y, this.dispersionAmount / Math.max(1, this.dispersionFactor));\r\n            this.dispersionAmount = Math.max(this.dispersionAmount, Math.max(Math.random() * 2, this.velocity * this.velocity) * this.dispersionFactor);\r\n            this.velocity += world.gravity;\r\n        }\r\n        else if (dustBelow.physicsType === \"liquid\") {\r\n            this.velocity += world.gravity;\r\n            this.velocity *= 0.5;\r\n            this.dispersionAmount = Math.max(this.dispersionAmount, Math.sqrt(Math.max(Math.random(), this.velocity)) * this.dispersionFactor);\r\n        }\r\n        else {\r\n            // Try to disperse the sand sideways\r\n            var dispersionResult = this.tryDisperse(world, newX, newY);\r\n            if (dispersionResult !== null) {\r\n                newX = dispersionResult.x;\r\n                newY = dispersionResult.y;\r\n                if (dispersionResult.x == x) {\r\n                    this.velocity = 0;\r\n                    this.dispersionAmount = 0;\r\n                }\r\n            }\r\n            this.dispersionAmount = Math.max(0, Math.floor(this.dispersionAmount * 0.5 - 5));\r\n            this.ySubPixel = 0;\r\n        }\r\n        // Try to move\r\n        var targetY = Math.ceil(newY + this.velocity + this.ySubPixel);\r\n        this.ySubPixel = newY + this.velocity + this.ySubPixel - targetY;\r\n        for (var stepY = newY + 1; stepY <= targetY; stepY++) {\r\n            var dustAtPosition = world.dust.get(newX, stepY);\r\n            if (this.canMoveInto(dustAtPosition)) {\r\n                newY = stepY;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (newX == x && newY == y && this.velocity == 0 && this.dispersionAmount == 0) {\r\n            // Inactivate the dust spec as no further movement will occur\r\n            this.active = false;\r\n        }\r\n        else {\r\n            // Update the position\r\n            var dustAtTarget = world.dust.get(newX, newY);\r\n            dustAtTarget === null || dustAtTarget === void 0 ? void 0 : dustAtTarget.activate();\r\n            world.dust.set(x, y, dustAtTarget);\r\n            world.dust.set(newX, newY, this);\r\n            // Agitate neighbors\r\n            world.dust.getNeighbors(x, y, this.dispersionDistance)\r\n                .forEach(function (dust) {\r\n                if (dust[0].physicsType == \"sand\") {\r\n                    dust[0].dispersionAmount = Math.max(dust[0].dispersionAmount, Math.max(0, _this.dispersionAmount * 0.8 - dust[1]));\r\n                }\r\n                dust[0].activate();\r\n            });\r\n        }\r\n    };\r\n    Sand.prototype.tryDisperse = function (world, x, y) {\r\n        var directions = Math.random() < 0.5 ? [-1, 1] : [1, -1];\r\n        var distance = 1;\r\n        if (this.dispersionAmount == 0) {\r\n            return { x: x, y: y, dispersion: 0 };\r\n        }\r\n        while (true) {\r\n            var possibleDirections = directions;\r\n            for (var i = 0; i < directions.length; i++) {\r\n                var dir = directions[i];\r\n                var dustAtPosition = world.dust.get(x + dir * distance, y);\r\n                var dustBelow = world.dust.get(x + dir * distance, y + 1);\r\n                if (this.canMoveInto(dustAtPosition)) {\r\n                    // We can move into this space\r\n                    // There is a random chance that we don't move any further\r\n                    var random = Math.random();\r\n                    if (this.canMoveInto(dustBelow) && random < 0.5 || random < distance / this.dispersionAmount) {\r\n                        if (this.canMoveInto(dustBelow)) {\r\n                            return { x: x + distance * dir, y: y + 1, dispersion: distance };\r\n                        }\r\n                        else {\r\n                            return { x: x + distance * dir, y: y, dispersion: distance };\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // It is not possible to advance in this direction\r\n                    if (possibleDirections.length === 2) {\r\n                        // Keep on searching in the other direction\r\n                        possibleDirections = [-dir];\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        // We cannot move any further in any direction\r\n                        return { x: x + (distance - 1) * dir, y: y, dispersion: (distance - 1) };\r\n                    }\r\n                }\r\n            }\r\n            directions = possibleDirections;\r\n            distance = distance + 1;\r\n        }\r\n    };\r\n    Sand.prototype.canMoveInto = function (space) {\r\n        return space === null || space.physicsType === \"liquid\";\r\n    };\r\n    return Sand;\r\n}(_Dust__WEBPACK_IMPORTED_MODULE_0__.DustBase));\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/DustType/Sand.ts?");

/***/ }),

/***/ "./src/DustType/Solid.ts":
/*!*******************************!*\
  !*** ./src/DustType/Solid.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Solid\": () => (/* binding */ Solid)\n/* harmony export */ });\n/* harmony import */ var _Dust__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Dust */ \"./src/Dust.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\nvar Solid = /** @class */ (function (_super) {\r\n    __extends(Solid, _super);\r\n    function Solid() {\r\n        var _this = _super.call(this, {\r\n            red: 100,\r\n            blue: 100,\r\n            green: 100\r\n        }) || this;\r\n        _this.physicsType = \"solid\";\r\n        _this.active = false;\r\n        return _this;\r\n    }\r\n    Solid.prototype.step = function () {\r\n        this.active = false;\r\n    };\r\n    return Solid;\r\n}(_Dust__WEBPACK_IMPORTED_MODULE_0__.DustBase));\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/DustType/Solid.ts?");

/***/ }),

/***/ "./src/Helpers/math.ts":
/*!*****************************!*\
  !*** ./src/Helpers/math.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vec\": () => (/* binding */ Vec),\n/* harmony export */   \"AABB\": () => (/* binding */ AABB),\n/* harmony export */   \"Intersect\": () => (/* binding */ Intersect)\n/* harmony export */ });\nvar Vec = /** @class */ (function () {\r\n    function Vec(a, b) {\r\n        this.a = a;\r\n        this.b = b;\r\n    }\r\n    Vec.prototype.add = function (b) {\r\n        return new Vec(this.a + b.a, this.b + b.b);\r\n    };\r\n    Vec.prototype.subtract = function (b) {\r\n        return new Vec(this.a - b.a, this.b - b.b);\r\n    };\r\n    Vec.prototype.addScalar = function (a) {\r\n        return new Vec(this.a + a, this.b + a);\r\n    };\r\n    Vec.prototype.multiply = function (a) {\r\n        return new Vec(this.a * a, this.b * a);\r\n    };\r\n    Vec.prototype.length = function () {\r\n        return Math.sqrt(this.a * this.a + this.b * this.b);\r\n    };\r\n    Vec.prototype.norm = function () {\r\n        var length = this.length();\r\n        return new Vec(this.a / length, this.b / length);\r\n    };\r\n    return Vec;\r\n}());\r\n\r\nvar AABB = /** @class */ (function () {\r\n    function AABB(a, b) {\r\n        this.a = a;\r\n        this.b = b;\r\n    }\r\n    AABB.prototype.intersects = function (other) {\r\n        var xIntersect = Math.max(this.a.a, other.a.a) - Math.min(this.b.a, other.b.a) <= 0;\r\n        var yIntersect = Math.max(this.a.b, other.a.b) - Math.min(this.b.b, other.b.b) <= 0;\r\n        return xIntersect && yIntersect;\r\n    };\r\n    return AABB;\r\n}());\r\n\r\nvar Intersect = /** @class */ (function () {\r\n    function Intersect() {\r\n    }\r\n    return Intersect;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/Helpers/math.ts?");

/***/ }),

/***/ "./src/QuadTree/DustQuadTree.ts":
/*!**************************************!*\
  !*** ./src/QuadTree/DustQuadTree.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"DustQuadTreeNode\": () => (/* binding */ DustQuadTreeNode)\n/* harmony export */ });\nvar DustQuadTree = /** @class */ (function () {\r\n    function DustQuadTree(maxDepth, width, height) {\r\n        this.originX = 0;\r\n        this.originY = 0;\r\n        this.maxDepth = maxDepth;\r\n        // Use the smalles power of two which covers the entire dust map as the root scale\r\n        this.rootScale = Math.pow(2, Math.ceil(Math.log2(Math.max(width, height))));\r\n    }\r\n    DustQuadTree.prototype.build = function (dust) {\r\n        this.rootNode = new DustQuadTreeNode();\r\n        this.rootNode.build(dust, this.originX, this.originY, this.rootScale, 0, this.maxDepth);\r\n    };\r\n    DustQuadTree.prototype.replace = function (x, y, previousPhysicsType, newPhysicsType) {\r\n        this.rootNode.replace(x, y, previousPhysicsType, newPhysicsType, this.originX, this.originY, this.rootScale, 0, this.maxDepth);\r\n    };\r\n    DustQuadTree.prototype.render = function (ctx, scale) {\r\n        this.rootNode.render(ctx, this.originX, this.originY, this.rootScale * scale);\r\n    };\r\n    return DustQuadTree;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DustQuadTree);\r\nvar DustQuadTreeNode = /** @class */ (function () {\r\n    function DustQuadTreeNode() {\r\n        this.containedPhysicsTypes = {};\r\n        // Whether this child node has been detached from it's parent\r\n        this.hanging = false;\r\n    }\r\n    Object.defineProperty(DustQuadTreeNode.prototype, \"isDivided\", {\r\n        get: function () {\r\n            return this.childNodes !== undefined;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    DustQuadTreeNode.prototype.render = function (ctx, originX, originY, scale) {\r\n        ctx.strokeStyle = [\"solid\", \"sand\"].includes(this.physicsType) ? \"red\" : \"black\";\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(originX, originY, scale, scale);\r\n        if (this.isDivided) {\r\n            var childScale = scale * 0.5;\r\n            this.childNodes[0].render(ctx, originX, originY, childScale);\r\n            this.childNodes[1].render(ctx, originX + childScale, originY, childScale);\r\n            this.childNodes[2].render(ctx, originX, originY + childScale, childScale);\r\n            this.childNodes[3].render(ctx, originX + childScale, originY + childScale, childScale);\r\n        }\r\n    };\r\n    DustQuadTreeNode.prototype.replace = function (x, y, previousPhysicsType, newPhysicsType, originX, originY, scale, depth, maxDepth) {\r\n        var _a, _b, _c, _d;\r\n        var _this = this;\r\n        var childScale = scale * 0.5;\r\n        // Subtract the old physics type\r\n        this.containedPhysicsTypes[previousPhysicsType] -= 1;\r\n        if (this.containedPhysicsTypes[previousPhysicsType] === 0) {\r\n            delete this.containedPhysicsTypes[previousPhysicsType];\r\n        }\r\n        // Add the new physics type\r\n        if (this.containedPhysicsTypes[newPhysicsType] === undefined) {\r\n            this.containedPhysicsTypes[newPhysicsType] = 1;\r\n        }\r\n        else {\r\n            this.containedPhysicsTypes[newPhysicsType] += 1;\r\n        }\r\n        if (Object.keys(this.containedPhysicsTypes).length === 1) {\r\n            // Only one physics type was found\r\n            this.physicsType = Object.keys(this.containedPhysicsTypes)[0];\r\n            if (this.isDivided) {\r\n                // Remove the child nodes as there is no longer a need for this node to be divided\r\n                this.childNodes.forEach(function (node) { return node.hanging = true; });\r\n                this.childNodes = undefined;\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            // Calculate the most common physics type in the node\r\n            var mostCommonPhysicsType = Object.keys(this.containedPhysicsTypes).reduce(function (a, b) { return _this.containedPhysicsTypes[a] > _this.containedPhysicsTypes[b] ? a : b; });\r\n            if (!this.isDivided && depth < maxDepth) {\r\n                // Divide the node, if possible\r\n                this.childNodes = [];\r\n                this.childNodes.push(new DustQuadTreeNode());\r\n                this.childNodes.push(new DustQuadTreeNode());\r\n                this.childNodes.push(new DustQuadTreeNode());\r\n                this.childNodes.push(new DustQuadTreeNode());\r\n                // If a node has been divided, it means it was previously only a single physics type\r\n                // We can therefore prefill the nodes with the correct types\r\n                this.childNodes[0].containedPhysicsTypes = (_a = {}, _a[this.physicsType] = childScale * childScale, _a);\r\n                this.childNodes[0].physicsType = this.physicsType;\r\n                this.childNodes[1].containedPhysicsTypes = (_b = {}, _b[this.physicsType] = childScale * childScale, _b);\r\n                this.childNodes[1].physicsType = this.physicsType;\r\n                this.childNodes[2].containedPhysicsTypes = (_c = {}, _c[this.physicsType] = childScale * childScale, _c);\r\n                this.childNodes[2].physicsType = this.physicsType;\r\n                this.childNodes[3].containedPhysicsTypes = (_d = {}, _d[this.physicsType] = childScale * childScale, _d);\r\n                this.childNodes[3].physicsType = this.physicsType;\r\n            }\r\n            this.physicsType = mostCommonPhysicsType;\r\n            if (this.isDivided) {\r\n                // Insert the dust particle into the correct child node\r\n                var dx = x < originX + childScale ? 0 : 1;\r\n                var dy = y < originY + childScale ? 0 : 1;\r\n                var childNode = this.childNodes[dx + 2 * dy];\r\n                childNode.replace(x, y, previousPhysicsType, newPhysicsType, originX + dx * childScale, originY + dy * childScale, childScale, depth + 1, maxDepth);\r\n            }\r\n        }\r\n    };\r\n    DustQuadTreeNode.prototype.build = function (data, originX, originY, scale, depth, maxDepth) {\r\n        var _this = this;\r\n        this.containedPhysicsTypes = {};\r\n        // Count all the physics types contained in this node\r\n        for (var x = originX; x < originX + scale; x++) {\r\n            for (var y = originY; y < originY + scale; y++) {\r\n                if (depth === maxDepth)\r\n                    debugger;\r\n                var dust = data.get(x, y);\r\n                var physicsType = dust === null ? \"nothing\" : dust.physicsType;\r\n                if (this.containedPhysicsTypes[physicsType] === undefined) {\r\n                    this.containedPhysicsTypes[physicsType] = 1;\r\n                }\r\n                else {\r\n                    this.containedPhysicsTypes[physicsType] += 1;\r\n                }\r\n            }\r\n        }\r\n        if (Object.keys(this.containedPhysicsTypes).length === 1) {\r\n            // Only one physics type was found\r\n            this.physicsType = Object.keys(this.containedPhysicsTypes)[0];\r\n            return;\r\n        }\r\n        else {\r\n            // Both where found\r\n            // Define the physics type as the most common\r\n            var mostCommonPhysicsType = Object.keys(this.containedPhysicsTypes).reduce(function (a, b) { return _this.containedPhysicsTypes[a] > _this.containedPhysicsTypes[b] ? a : b; });\r\n            this.physicsType = mostCommonPhysicsType;\r\n            if (depth < maxDepth) {\r\n                // Divide the node, if possible\r\n                var childScale = scale * 0.5;\r\n                this.childNodes = [];\r\n                this.childNodes.push(this.buildChild(data, originX, originY, depth + 1, childScale, maxDepth));\r\n                this.childNodes.push(this.buildChild(data, originX + childScale, originY, depth + 1, childScale, maxDepth));\r\n                this.childNodes.push(this.buildChild(data, originX, originY + childScale, depth + 1, childScale, maxDepth));\r\n                this.childNodes.push(this.buildChild(data, originX + childScale, originY + childScale, depth + 1, childScale, maxDepth));\r\n            }\r\n        }\r\n    };\r\n    DustQuadTreeNode.prototype.buildChild = function (data, originX, originY, depth, scale, maxDepth) {\r\n        var child = new DustQuadTreeNode();\r\n        child.build(data, originX, originY, scale, depth, maxDepth);\r\n        return child;\r\n    };\r\n    return DustQuadTreeNode;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/QuadTree/DustQuadTree.ts?");

/***/ }),

/***/ "./src/QuadTree/ray.ts":
/*!*****************************!*\
  !*** ./src/QuadTree/ray.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Helpers_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/math */ \"./src/Helpers/math.ts\");\n\r\nvar Ray = /** @class */ (function () {\r\n    function Ray(origin, direction) {\r\n        this.origin = origin;\r\n        this.direction = direction.norm();\r\n        this.inverseDirection = new _Helpers_math__WEBPACK_IMPORTED_MODULE_0__.Vec(1 / this.direction.a, 1 / this.direction.b);\r\n    }\r\n    Ray.prototype.IntersectBox = function (box) {\r\n        // Caculate the intersect\r\n        return {\r\n            tMin: Math.max(this.gettx(box.a.a), this.getty(box.a.b)),\r\n            tMax: Math.min(this.gettx(box.b.a), this.getty(box.b.b)),\r\n        };\r\n    };\r\n    Ray.prototype.gettx = function (x) {\r\n        return (x - this.origin.a) * this.inverseDirection.a;\r\n    };\r\n    Ray.prototype.getty = function (y) {\r\n        return (y - this.origin.b) * this.inverseDirection.b;\r\n    };\r\n    Ray.prototype.getPoint = function (t) {\r\n        return this.origin.add(this.direction.multiply(t));\r\n    };\r\n    Ray.prototype.intersectQuadTree = function (tree, maxDepth) {\r\n        // Ray mirrored so it enters the box from the top left.\r\n        // This allows implementing code, assuming that this is the case and using a bitmask to get correct code\r\n        var tlRay = new Ray(new _Helpers_math__WEBPACK_IMPORTED_MODULE_0__.Vec(this.direction.a < 0 ? -this.origin.a + tree.rootScale : this.origin.a, this.direction.b < 0 ? -this.origin.b + tree.rootScale : this.origin.b), new _Helpers_math__WEBPACK_IMPORTED_MODULE_0__.Vec(Math.abs(this.direction.a), Math.abs(this.direction.b)));\r\n        // Bitmask use to fix child indices if ray isn't traveling in +/+ direction\r\n        var childIndexMask = (this.direction.a > 0 ? 0 : 1) + (this.direction.b > 0 ? 0 : 2);\r\n        var stack = [];\r\n        if (maxDepth === undefined) {\r\n            // If no max depth has been specified, go thorugh the tree to the highest level of detail\r\n            maxDepth = Number.POSITIVE_INFINITY;\r\n        }\r\n        // Push the root node to the stack\r\n        // In a real implementation mayDescend would be determined by whether or not the node has any children\r\n        stack.push({\r\n            index: 0,\r\n            origin: new _Helpers_math__WEBPACK_IMPORTED_MODULE_0__.Vec(0, 0),\r\n            mayDescend: maxDepth > 1,\r\n            quadNode: tree.rootNode\r\n        });\r\n        do {\r\n            var scale = tree.rootScale / Math.pow(2, stack.length - 1);\r\n            var currentNode = stack[stack.length - 1];\r\n            // Check for hit\r\n            if ([\"solid\", \"sand\"].includes(currentNode.quadNode.physicsType) && (stack.length === maxDepth || !currentNode.quadNode.isDivided)) {\r\n                // We have a hit.\r\n                var hit = Math.max(tlRay.gettx(currentNode.origin.a), tlRay.getty(currentNode.origin.b));\r\n                if (this.length === undefined || hit > 0) {\r\n                    // If the ray is capped, only return the hit if it is after the origin\r\n                    return hit;\r\n                }\r\n            }\r\n            // Descend to the first child\r\n            if (currentNode.mayDescend && currentNode.quadNode.isDivided) {\r\n                var childIndex = Ray.getFirstChildIndex(tlRay, currentNode.origin, scale);\r\n                // Since the tree is traversed using a mirrored ray, the actual child index is childIndex ^ childIndexMask\r\n                var childOrigin = Ray.getChildOrigin(currentNode.origin, scale, childIndex);\r\n                stack.push({\r\n                    index: childIndex,\r\n                    origin: childOrigin,\r\n                    mayDescend: stack.length + 1 < maxDepth,\r\n                    quadNode: currentNode.quadNode.childNodes[childIndex ^ childIndexMask]\r\n                });\r\n            }\r\n            else {\r\n                // We are at the max depth. Attempt to move on to the adjacent child instead\r\n                var childIndex = Ray.getNextChildIndex(currentNode.origin, scale, currentNode.index, tlRay);\r\n                if (childIndex !== null) {\r\n                    // Adjacent child was found\r\n                    stack[stack.length - 1] = {\r\n                        index: childIndex,\r\n                        origin: Ray.getChildOrigin(stack[stack.length - 2].origin, scale * 2, childIndex),\r\n                        mayDescend: stack.length < maxDepth,\r\n                        quadNode: stack[stack.length - 2].quadNode.childNodes[childIndex ^ childIndexMask]\r\n                    };\r\n                }\r\n                else {\r\n                    // No adjacent child was found.\r\n                    stack.pop();\r\n                    stack[stack.length - 1].mayDescend = false;\r\n                }\r\n            }\r\n        } while (stack.length > 1);\r\n        return Number.POSITIVE_INFINITY;\r\n    };\r\n    /**\r\n     * Gets the index of the first child the ray enters in the quad-node.\r\n     * Assumes that the ray has a x+, y+ direction. Other rays must be mirrored to become x+, y+ and the mask can be used to get the correct result\r\n     * @param ray The ray entering the quad-node. The ray must originate from top left.\r\n     * @param parentNode The parent node\r\n     * @param parentScale The scale of the parent node\r\n     * @param mask If the ray didn't originally come from top left, the mask can be used to get the correct index for the orientaiton\r\n     */\r\n    Ray.getFirstChildIndex = function (ray, parentOrigin, parentScale) {\r\n        var tx0 = ray.gettx(parentOrigin.a);\r\n        var tx1 = ray.gettx(parentOrigin.a + parentScale * 0.5);\r\n        var ty0 = ray.getty(parentOrigin.b);\r\n        var ty1 = ray.getty(parentOrigin.b + parentScale * 0.5);\r\n        // The ray enters in one of the top two squares\r\n        // ty1 < tx0 -> The ray enters square 2 (from the left side)\r\n        // tx1 < ty0 -> The ray enters square 1 (from the top side)\r\n        // If neither, the ray enters square 0\r\n        return ((ty1 < tx0 ? 1 : 0) * 2 + (tx1 < ty0 ? 1 : 0));\r\n    };\r\n    Ray.getChildOrigin = function (parentOrigin, parentScale, childIndex) {\r\n        return new _Helpers_math__WEBPACK_IMPORTED_MODULE_0__.Vec((childIndex & 1) * parentScale * 0.5, (childIndex & 2) * 0.5 * parentScale * 0.5).add(parentOrigin);\r\n    };\r\n    Ray.getNextChildIndex = function (currentChildOrigin, childSize, currentChildIndex, ray) {\r\n        // Since it is assumed that the ray moves in the +/+ direction\r\n        // The ray can only exit the current child below or to the right\r\n        var tRight = ray.gettx(currentChildOrigin.a + childSize);\r\n        var tBottom = ray.getty(currentChildOrigin.b + childSize);\r\n        var nextChildIndex = currentChildIndex | (tRight < tBottom ? 1 : 2);\r\n        if (nextChildIndex === currentChildIndex) {\r\n            return null;\r\n        }\r\n        return nextChildIndex;\r\n    };\r\n    return Ray;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Ray);\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/QuadTree/ray.ts?");

/***/ }),

/***/ "./src/World.ts":
/*!**********************!*\
  !*** ./src/World.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"World\": () => (/* binding */ World),\n/* harmony export */   \"DustMap\": () => (/* binding */ DustMap)\n/* harmony export */ });\n/* harmony import */ var _DustType_Solid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DustType/Solid */ \"./src/DustType/Solid.ts\");\n/* harmony import */ var _Helpers_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Helpers/math */ \"./src/Helpers/math.ts\");\n/* harmony import */ var _QuadTree_DustQuadTree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./QuadTree/DustQuadTree */ \"./src/QuadTree/DustQuadTree.ts\");\n/* harmony import */ var _QuadTree_ray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QuadTree/ray */ \"./src/QuadTree/ray.ts\");\n\r\n\r\n\r\n\r\nvar World = /** @class */ (function () {\r\n    function World(width, height) {\r\n        this.gravity = 0.1;\r\n        this.frame = 0;\r\n        this.dust = new DustMap(width, height);\r\n        this.frame = 0;\r\n        // Create a floor\r\n        for (var y = Math.floor(height * 0.9); y < height; y++) {\r\n            for (var x = 0; x < width; x++) {\r\n                this.dust.set(x, y, new _DustType_Solid__WEBPACK_IMPORTED_MODULE_0__.Solid());\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(World.prototype, \"width\", {\r\n        get: function () { return this.dust.width; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(World.prototype, \"height\", {\r\n        get: function () { return this.dust.height; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    World.prototype.step = function () {\r\n        var xStepDirection = this.frame % 2 === 0 ? -1 : 1;\r\n        var activeCount = 0;\r\n        for (var y = this.height - 1; y >= 0; y--) {\r\n            var layerActive = false;\r\n            for (var i = 0; i < this.width; i++) {\r\n                var x = xStepDirection == 1 ? i : this.width - 1 - i;\r\n                var dust = this.dust.get(x, y);\r\n                if (dust !== null && dust.active) {\r\n                    activeCount++;\r\n                    layerActive = true;\r\n                    dust.step(this, x, y);\r\n                }\r\n            }\r\n        }\r\n        this.frame = this.frame + 1;\r\n        this.dust.rebuildQuadTree(10);\r\n    };\r\n    return World;\r\n}());\r\n\r\nvar DustMap = /** @class */ (function () {\r\n    function DustMap(width, height) {\r\n        // Keep track of every time a physics type was changed since the quad tree was last rebuild\r\n        this.physicsTypeChanges = {};\r\n        this.width = width;\r\n        this.height = height;\r\n        this.data = Array(width * height).fill(null);\r\n        this.imageData = new ImageData(this.width, this.height);\r\n        this.renderAll();\r\n        this.quadTree = new _QuadTree_DustQuadTree__WEBPACK_IMPORTED_MODULE_2__.default(20, width, height);\r\n        this.quadTree.build(this);\r\n    }\r\n    DustMap.prototype.renderDust = function (index, red, green, blue) {\r\n        this.imageData.data[index * 4] = red;\r\n        this.imageData.data[index * 4 + 1] = green;\r\n        this.imageData.data[index * 4 + 2] = blue;\r\n        this.imageData.data[index * 4 + 3] = 255;\r\n    };\r\n    DustMap.prototype.get = function (x, y) {\r\n        if (x < 0 || y < 0 || x >= this.width || y >= this.width) {\r\n            return null;\r\n        }\r\n        return this.data[this.getDustIndex(x, y)];\r\n    };\r\n    DustMap.prototype.set = function (x, y, dust) {\r\n        var _this = this;\r\n        var _a, _b, _c, _d, _e;\r\n        if (x < 0 || y < 0 || x >= this.width || y >= this.width) {\r\n            return;\r\n        }\r\n        var index = this.getDustIndex(x, y);\r\n        // Register the change to the quad tree\r\n        if (this.physicsTypeChanges[index] === undefined) {\r\n            if (((_a = this.data[index]) === null || _a === void 0 ? void 0 : _a.physicsType) !== (dust === null || dust === void 0 ? void 0 : dust.physicsType)) {\r\n                this.physicsTypeChanges[index] = [(_c = (_b = this.data[index]) === null || _b === void 0 ? void 0 : _b.physicsType) !== null && _c !== void 0 ? _c : \"nothing\", (_d = dust === null || dust === void 0 ? void 0 : dust.physicsType) !== null && _d !== void 0 ? _d : \"nothing\"];\r\n            }\r\n        }\r\n        else {\r\n            this.physicsTypeChanges[index] = [this.physicsTypeChanges[index][0], (_e = dust === null || dust === void 0 ? void 0 : dust.physicsType) !== null && _e !== void 0 ? _e : \"nothing\"];\r\n            if (this.physicsTypeChanges[index][0] === this.physicsTypeChanges[index][1]) {\r\n                delete this.physicsTypeChanges[index];\r\n            }\r\n        }\r\n        // Update the map data\r\n        this.data[index] = dust;\r\n        // Render the updated dust to the texture\r\n        if (dust !== null) {\r\n            dust.render(function (red, green, blue) { return _this.renderDust(index, red, green, blue); });\r\n        }\r\n        else {\r\n            this.renderDust(index, 255, 255, 255);\r\n        }\r\n    };\r\n    DustMap.prototype.getDustIndex = function (x, y) {\r\n        return y * this.width + x;\r\n    };\r\n    DustMap.prototype.renderAll = function () {\r\n        var _this = this;\r\n        var _loop_1 = function (i) {\r\n            if (this_1.data[i] === null) {\r\n                this_1.renderDust(i, 255, 255, 255);\r\n            }\r\n            else {\r\n                this_1.data[i].render(function (red, green, blue) { return _this.renderDust(i, red, green, blue); });\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var i = 0; i < this.width * this.height; i++) {\r\n            _loop_1(i);\r\n        }\r\n    };\r\n    DustMap.prototype.fillCircle = function (center, radius, getDust) {\r\n        center = { x: Math.floor(center.x), y: Math.floor(center.y) };\r\n        if (radius == 0) {\r\n            this.set(center.x, center.y, getDust(center.x, center.y));\r\n            return;\r\n        }\r\n        for (var x = Math.max(center.x - radius, 0); x < center.x + radius * 2 && x < this.width; x++) {\r\n            for (var y = Math.max(center.y - radius, 0); y < center.y + radius * 2 && y < this.height; y++) {\r\n                if ((x - center.x) * (x - center.x) + (y - center.y) * (y - center.y) <= radius * radius) {\r\n                    var previousDust = this.get(x, y);\r\n                    var newDust = getDust(x, y);\r\n                    if (newDust === null || previousDust === null || newDust.physicsType !== previousDust.physicsType) {\r\n                        this.set(x, y, newDust);\r\n                        this.activateAround(x, y);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    DustMap.prototype.getNeighbors = function (x, y, distance) {\r\n        if (distance === void 0) { distance = 1; }\r\n        var result = [];\r\n        for (var x1 = x - distance; x1 <= x + distance; x1++) {\r\n            for (var y1 = y - distance; y1 <= y + distance; y1++) {\r\n                // Don't activate the tile itself\r\n                if (x1 == x && y1 == y)\r\n                    continue;\r\n                var dust = this.get(x1, y1);\r\n                if (dust != null) {\r\n                    result.push([dust, (x - x1) * (x - x1) + (y - y1) * (y - y1)]);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    DustMap.prototype.activateAround = function (x, y) {\r\n        this.getNeighbors(x, y).forEach(function (dust) { return dust[0].activate(); });\r\n    };\r\n    DustMap.prototype.rebuildQuadTree = function (limit) {\r\n        var changedIndeces = Object.keys(this.physicsTypeChanges);\r\n        for (var i = 0; i < changedIndeces.length && (limit === undefined || i < limit); i++) {\r\n            var index = Number(changedIndeces[i]);\r\n            var x = index % this.width;\r\n            var y = (index - x) / this.width;\r\n            var change = this.physicsTypeChanges[index];\r\n            this.quadTree.replace(x, y, change[0], change[1]);\r\n            delete this.physicsTypeChanges[index];\r\n        }\r\n    };\r\n    DustMap.prototype.traceRay = function (origin, direction, shouldStop, length, maxDepth) {\r\n        // Ray mirrored so it enters the box from the top left.\r\n        // This allows implementing code, assuming that this is the case and using a bitmask to get correct code\r\n        var tlRay = new _QuadTree_ray__WEBPACK_IMPORTED_MODULE_3__.default(new _Helpers_math__WEBPACK_IMPORTED_MODULE_1__.Vec(direction.a < 0 ? -origin.a + this.quadTree.rootScale : origin.a, direction.b < 0 ? -origin.b + this.quadTree.rootScale : origin.b), new _Helpers_math__WEBPACK_IMPORTED_MODULE_1__.Vec(Math.abs(direction.a), Math.abs(direction.b)));\r\n        // Bitmask use to fix child indices if ray isn't traveling in +/+ direction\r\n        var childIndexMask = (direction.a > 0 ? 0 : 1) + (direction.b > 0 ? 0 : 2);\r\n        var stack = [];\r\n        if (maxDepth === undefined) {\r\n            // If no max depth has been specified, go thorugh the tree to the highest level of detail\r\n            maxDepth = Number.POSITIVE_INFINITY;\r\n        }\r\n        // Push the root node to the stack\r\n        // In a real implementation mayDescend would be determined by whether or not the node has any children\r\n        stack.push({\r\n            index: 0,\r\n            origin: new _Helpers_math__WEBPACK_IMPORTED_MODULE_1__.Vec(0, 0),\r\n            mayDescend: maxDepth > 1,\r\n            quadNode: this.quadTree.rootNode\r\n        });\r\n        do {\r\n            var scale = this.quadTree.rootScale / Math.pow(2, stack.length - 1);\r\n            var currentNode = stack[stack.length - 1];\r\n            if (!currentNode.quadNode.isDivided) {\r\n                // Make sure that all dust within this node has been processed\r\n                var modified = false;\r\n                for (var x = Math.max(0, currentNode.origin.a); x < Math.min(this.width, currentNode.origin.a + scale); x++) {\r\n                    for (var y = Math.max(0, currentNode.origin.b); y < Math.min(this.height, currentNode.origin.b + scale); y++) {\r\n                        var index = this.getDustIndex(x, y);\r\n                        if (this.physicsTypeChanges[index] !== undefined) {\r\n                            modified = true;\r\n                            var change = this.physicsTypeChanges[index];\r\n                            delete this.physicsTypeChanges[index];\r\n                            this.quadTree.replace(x, y, change[0], change[1]);\r\n                        }\r\n                    }\r\n                }\r\n                if (modified) {\r\n                    // There were changed made to the tree. We need to ascend beyond any hanging (was removed) parent\r\n                    var ascended = false;\r\n                    for (var index = stack.length - 1; index >= 0; index--) {\r\n                        if (stack[index].quadNode.hanging) {\r\n                            // Ascend to the last parent that isn't hanging\r\n                            for (var position = stack.length - 1; position >= index; position--) {\r\n                                stack.pop();\r\n                            }\r\n                            stack[stack.length - 1].mayDescend = false;\r\n                            ascended = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (ascended)\r\n                        continue;\r\n                }\r\n            }\r\n            // Check for hit\r\n            if (shouldStop(currentNode.quadNode.physicsType) && (stack.length === maxDepth || !currentNode.quadNode.isDivided)) {\r\n                // We have a hit.\r\n                var hit = Math.max(tlRay.gettx(currentNode.origin.a), tlRay.getty(currentNode.origin.b));\r\n                if (length === undefined || hit > 0) {\r\n                    // If the ray is capped, only return the hit if it is after the origin\r\n                    return hit;\r\n                }\r\n            }\r\n            // Descend to the first child\r\n            if (currentNode.mayDescend && currentNode.quadNode.isDivided) {\r\n                var childIndex = _QuadTree_ray__WEBPACK_IMPORTED_MODULE_3__.default.getFirstChildIndex(tlRay, currentNode.origin, scale);\r\n                // Since the tree is traversed using a mirrored ray, the actual child index is childIndex ^ childIndexMask\r\n                var childOrigin = _QuadTree_ray__WEBPACK_IMPORTED_MODULE_3__.default.getChildOrigin(currentNode.origin, scale, childIndex);\r\n                stack.push({\r\n                    index: childIndex,\r\n                    origin: childOrigin,\r\n                    mayDescend: stack.length + 1 < maxDepth,\r\n                    quadNode: currentNode.quadNode.childNodes[childIndex ^ childIndexMask]\r\n                });\r\n            }\r\n            else {\r\n                // We are at the max depth. Attempt to move on to the adjacent child instead\r\n                var childIndex = _QuadTree_ray__WEBPACK_IMPORTED_MODULE_3__.default.getNextChildIndex(currentNode.origin, scale, currentNode.index, tlRay);\r\n                if (childIndex !== null) {\r\n                    // Adjacent child was found\r\n                    stack[stack.length - 1] = {\r\n                        index: childIndex,\r\n                        origin: _QuadTree_ray__WEBPACK_IMPORTED_MODULE_3__.default.getChildOrigin(stack[stack.length - 2].origin, scale * 2, childIndex),\r\n                        mayDescend: stack.length < maxDepth,\r\n                        quadNode: stack[stack.length - 2].quadNode.childNodes[childIndex ^ childIndexMask]\r\n                    };\r\n                }\r\n                else {\r\n                    // No adjacent child was found.\r\n                    stack.pop();\r\n                    stack[stack.length - 1].mayDescend = false;\r\n                }\r\n            }\r\n        } while (stack.length > 1);\r\n        return Number.POSITIVE_INFINITY;\r\n    };\r\n    return DustMap;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/World.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _DustType_Gravel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DustType/Gravel */ \"./src/DustType/Gravel.ts\");\n/* harmony import */ var _DustType_Sand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DustType/Sand */ \"./src/DustType/Sand.ts\");\n/* harmony import */ var _DustType_Solid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DustType/Solid */ \"./src/DustType/Solid.ts\");\n/* harmony import */ var _DustType_Liquid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DustType/Liquid */ \"./src/DustType/Liquid.ts\");\n/* harmony import */ var _World__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./World */ \"./src/World.ts\");\n/* harmony import */ var _DustType_Gas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DustType/Gas */ \"./src/DustType/Gas.ts\");\n/* harmony import */ var _QuadTree_ray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./QuadTree/ray */ \"./src/QuadTree/ray.ts\");\n/* harmony import */ var _Helpers_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Helpers/math */ \"./src/Helpers/math.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar canvas = null;\r\nvar dustTypes = [\"none\", \"solid\", \"sand\", \"gravel\", \"water\", \"gas\"];\r\nvar currentDustIndex = 0;\r\nvar isDrawingDust = false;\r\nvar renderQuadTree = false;\r\nvar drawRadius = 10;\r\nvar scale = 1;\r\nvar mousePos = { x: 0, y: 0 };\r\nfunction load() {\r\n    document.body.style.margin = \"0\";\r\n    document.body.style.height = \"100vh\";\r\n    document.body.style.overflow = \"hidden\";\r\n    window.addEventListener(\"resize\", resize);\r\n    canvas = document.createElement(\"canvas\");\r\n    canvas.addEventListener(\"mousedown\", mouseDown);\r\n    canvas.addEventListener(\"mouseup\", function () { return isDrawingDust = false; });\r\n    canvas.addEventListener(\"mousemove\", mouseMove);\r\n    canvas.addEventListener(\"contextmenu\", function (ev) { return ev.preventDefault(); });\r\n    window.addEventListener(\"keydown\", keydown);\r\n    window.addEventListener(\"wheel\", function (ev) {\r\n        drawRadius = Math.max(0, drawRadius + Math.max(-1, Math.min(1, -ev.deltaY)));\r\n        console.log(drawRadius);\r\n    });\r\n    var ctx = canvas.getContext(\"2d\");\r\n    document.body.appendChild(canvas);\r\n    window.requestAnimationFrame(animationFrame);\r\n    var world = new _World__WEBPACK_IMPORTED_MODULE_4__.World(300, 300);\r\n    var rays = [];\r\n    resize();\r\n    function animationFrame() {\r\n        var _a;\r\n        if (isDrawingDust) {\r\n            world.dust.fillCircle({ x: mousePos.x / scale, y: mousePos.y / scale }, drawRadius, getDrawedDust);\r\n        }\r\n        world.step();\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        // Draw the map at scale 1 and then redraw it afterwards at the correct scale\r\n        ctx.putImageData(world.dust.imageData, 0, 0);\r\n        ctx.drawImage(ctx.canvas, 0, 0, world.width, world.height, 0, 0, world.width * scale, world.height * scale);\r\n        if (renderQuadTree)\r\n            world.dust.quadTree.render(ctx, scale);\r\n        var dustColor = (_a = getDrawedDust()) === null || _a === void 0 ? void 0 : _a.color;\r\n        ctx.strokeStyle = dustColor === undefined ? \"red\" : \"rgb(\" + dustColor.red + \", \" + dustColor.green + \", \" + dustColor.blue + \")\";\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        ctx.arc(mousePos.x, mousePos.y, drawRadius * scale, 0, 2 * Math.PI);\r\n        ctx.stroke();\r\n        rays.forEach(function (ray) {\r\n            ctx.beginPath();\r\n            ctx.strokeStyle = \"red\";\r\n            ctx.moveTo(ray.origin.a * scale, ray.origin.b * scale);\r\n            ctx.lineTo(ray.origin.a * scale + ray.direction.a * ray.length * scale, ray.origin.b * scale + ray.direction.b * ray.length * scale);\r\n            ctx.stroke();\r\n        });\r\n        window.requestAnimationFrame(animationFrame);\r\n    }\r\n    function getDrawedDust() {\r\n        switch (dustTypes[currentDustIndex]) {\r\n            case \"solid\":\r\n                return new _DustType_Solid__WEBPACK_IMPORTED_MODULE_2__.Solid();\r\n            case \"sand\":\r\n                return new _DustType_Sand__WEBPACK_IMPORTED_MODULE_1__.Sand();\r\n            case \"gravel\":\r\n                return new _DustType_Gravel__WEBPACK_IMPORTED_MODULE_0__.Gravel();\r\n            case \"water\":\r\n                return new _DustType_Liquid__WEBPACK_IMPORTED_MODULE_3__.Liquid();\r\n            case \"gas\":\r\n                return new _DustType_Gas__WEBPACK_IMPORTED_MODULE_5__.Gas();\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    function mouseDown(ev) {\r\n        if (ev.button == 0) {\r\n            isDrawingDust = true;\r\n        }\r\n        mouseMove(ev);\r\n        if (ev.button == 2) {\r\n            var rayCount = 100;\r\n            rays = [];\r\n            for (var i = 0; i < rayCount; i++) {\r\n                var angle = Math.PI * 2 / rayCount * i;\r\n                var ray = new _QuadTree_ray__WEBPACK_IMPORTED_MODULE_6__.default(new _Helpers_math__WEBPACK_IMPORTED_MODULE_7__.Vec(mousePos.x / scale, mousePos.y / scale), new _Helpers_math__WEBPACK_IMPORTED_MODULE_7__.Vec(Math.acos(angle), Math.asin(angle)).norm());\r\n                ray.length = world.dust.traceRay(ray.origin, ray.direction, function (step) { return [\"sand\", \"solid\"].includes(step); });\r\n                if (ray.length === Infinity)\r\n                    ray.length = 1000;\r\n                rays.push(ray);\r\n            }\r\n        }\r\n    }\r\n    function mouseMove(ev) {\r\n        var canvasBB = canvas.getBoundingClientRect();\r\n        mousePos.x = ev.clientX - canvasBB.x;\r\n        mousePos.y = ev.clientY - canvasBB.y;\r\n    }\r\n    function resize() {\r\n        if (canvas !== null) {\r\n            canvas.setAttribute(\"width\", document.body.clientWidth.toString());\r\n            canvas.setAttribute(\"height\", document.body.clientHeight.toString());\r\n            scale = Math.min(Math.floor(canvas.width / world.width), Math.floor(canvas.height / world.height));\r\n        }\r\n    }\r\n    function keydown(ev) {\r\n        if (ev.key === \"q\") {\r\n            renderQuadTree = !renderQuadTree;\r\n        }\r\n        if (Array.from({ length: 10 }, function (v, k) { return (k + 1).toString(); }).indexOf(ev.key) != -1) {\r\n            var index = Number(ev.key) - 1;\r\n            if (index >= 0 && index < dustTypes.length) {\r\n                currentDustIndex = index;\r\n                console.log(dustTypes[index]);\r\n            }\r\n        }\r\n    }\r\n}\r\nwindow.addEventListener(\"load\", load);\r\n\n\n//# sourceURL=webpack://fallingsandtest/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;